#!/usr/bin/env python
"""Unit testing for iterative deconvolution
"""

import os

import numpy as np
from scipy import signal
from seismic.receiver_fn.rf_config import RFConfig
from rf import RFStream
from seismic.receiver_fn.rf_synthetic import generate_synth_rf
from seismic.receiver_fn.rf_deconvolution import rf_iter_deconv
from obspy.core import UTCDateTime, Trace
from scipy.signal import find_peaks

def _generate_synthetic_source(times, amplitude=1):
    # Generate synthetic vertical seismic trace as a filtered decaying cosine. The exact form here shouldn't matter,
    # but better that it be plausible.
    g = amplitude*np.exp(-times/4)*np.cos(2*np.pi*1*times)
    g[times < 0] = 0
    # Apply weak filter to g to smooth onset, cutting off above 2.0 Hz
    filter_order = 2
    cutoff = 0.05  # normalized cutoff freq
    bw_filt = signal.butter(filter_order, cutoff)
    g = signal.filtfilt(bw_filt[0], bw_filt[1], g)

    return g
# end func


def _generate_radial_from_src(pure_rf, source_signal, times):
    # Use Rf and source signal to generate radial test signal
    f = signal.convolve(pure_rf, source_signal, mode='full')
    n_leadin = len(times[times < 0])
    f = f[n_leadin:n_leadin+len(times)]

    return f
# end func

def get_input_stream():
    np.random.seed(20240201)
    stats = {'network': 'AU',
             'station': 'MEEK',
             'location': '',
             'channel': 'BHL',
             'starttime': UTCDateTime(0),
             'endtime': UTCDateTime(250),
             'sampling_rate': 10.0,
             'delta': 0.1,
             'npts': 2500,
             'calib': 1.0,
             'arrival_time': UTCDateTime(100),
             'back_azimuth': 95.,
             'distance': 60.,
             'event_depth': 600,
             'event_id': 'smi:ISC/evid=612848327',
             'event_latitude': -20.,
             'event_longitude': 180.,
             'event_magnitude': 7.,
             'event_time': UTCDateTime(0) - 1200,
             'inclination': 25,
             'onset': UTCDateTime(100),
             'phase': 'S',
             'slowness': 12.,
             'station_elevation': 530.0,
             'station_latitude': -20,
             'station_longitude': 120,
             'wave_type': 'S'}

    # generate radial waveform with 4 peaks, convolved with a simple source
    times, synth = generate_synth_rf(arrival_times=[-20, 0, 15, 30], arrival_amplitudes=[0.3, 1, 0.2, 0.2],
                                     fs_hz=10, window_sec=[-100, 150], f_cutoff_hz=2)

    g = _generate_synthetic_source(times)
    f = _generate_radial_from_src(synth, g, times)

    noise = np.random.normal(scale=np.fabs(g).max()*1e-2, size=len(times))
    trc_l = Trace(data=f + noise*0, header=stats)
    trc_q = Trace(data=g + noise*0, header=stats)

    trc_q.stats.channel = 'BHQ'

    return stats['event_id'], RFStream([trc_l, trc_q])
# end func

def test_synthetic_srf():
    evid, stream = get_input_stream()

    rf_iter = stream.copy().rf(method='S', rotate=None, deconvolve='func', func=rf_iter_deconv,
                               normalize=1,
                               trim=(-100, 50),
                               winsrc=(-100, 50, 5),
                               both_sided=True)

    # find times of four peaks on radial component
    iter_peaks, _ = find_peaks(-rf_iter[0].data, distance=100, prominence=0.1)
    iter_times = rf_iter[0].times()[iter_peaks]
    iter_amps = rf_iter[0].data[iter_peaks]

    rf_freq = stream.copy().rf(method='S', rotate=None, deconvolve='freq',
                               normalize=1,
                               trim=(-100, 50),
                               winsrc=(-100, 50, 5))

    freq_peaks, _ = find_peaks(-rf_freq[0].data, distance=100, prominence=0.1)
    freq_times = rf_freq[0].times()[freq_peaks]
    freq_amps = rf_freq[0].data[freq_peaks]

    # check that peak-times in rf-iter and rf-freq matches
    assert np.all(iter_times == freq_times), 'Peak times vary between RFs generated by ' \
                                             'iterative and frequency domain deconvolution ' \
                                             'methods.'

    # check that amplitudes are roughly in agreement
    #print(iter_amps, freq_amps)
    assert np.allclose(iter_amps, freq_amps, rtol=1e-1)
# end func

if __name__ == "__main__":
    test_synthetic_srf()
