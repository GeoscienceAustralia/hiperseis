#!/usr/bin/env python
# coding: utf-8
"""
Objective function minimization solvers.
"""

import numpy as np
from scipy.optimize import Bounds
from scipy.optimize import OptimizeResult

# DEBUG ONLY
import matplotlib.pyplot as plt


class SolverGlobalMhMcmc:
    """
    Drop-in custom solver for scipy.optimize.minimize, based on Metrolpolis-Hastings Monte Carlo
    Markov Chain random walk with burn-in and adaptive acceptance rate, followed by N-dimensional
    clustering.

    Rather than returning one global solution, the solver returns the N best ranked local solutions.
    It also returns a probability distribution of each unknown based on Monte Carlo statistics.

    """
    pass
# end class


def propose_step(x, bounds, step_sigma):
    ndims = len(x)
    while True:
        dim = np.random.randint(0, ndims)
        x_new = x[dim] + step_sigma[dim]*np.random.randn()
        if x_new >= bounds.lb[dim] and x_new <= bounds.ub[dim]:
            break
        # end if
    # end while
    result = x.copy()
    result[dim] = x_new
    return result
# end func


# Compose as global function first, then abtract out into classes.
def optimize_minimize_mhmcmc_cluster(objective, bounds, args=(), x0=None, T=1, N=3, burnin=1000000, maxiter=10000000,
                                     target_ar=0.5):
    """
    Minimize objective function and return up to N solutions.

    :param objective: Objective function to minimize
    :param bounds: Bounds of the parameter space.
    :param args: Any additional fixed parameters needed to completely specify the objective function.
    :param x0: Initial guess. If None, will be selected randomly and uniformly within the parameter bounds.
    :param T: The "temperature" parameter for the accept or reject criterion.
    :param burnin: Number of random steps to discard before starting to accumulate statistics.
    :param maxiter: Maximum number of steps to take (including burnin).
    :param target_ar: Target acceptance rate of point samples generated by stepping.
    :return: OptimizeResult containing solution(s) and solver data.
    """
    assert maxiter > burnin, "maxiter {} not greater than burnin steps {}".format(maxiter, burnin)
    main_iter = maxiter - burnin

    beta = 1.0/T

    # DEBUG ONLY:
    np.random.seed(20200220)

    if x0 is None:
        x0 = np.random.uniform(bounds.lb, bounds.ub)
    # end if
    assert np.all((x0 >= bounds.lb) & (x0 <= bounds.ub))
    x = x0.copy()
    funval = objective(x, *args)

    sigma0 = 0.1*(bounds.ub - bounds.lb)
    sigma = sigma0.copy()

    from collections import deque
    x_queue = deque(maxlen=10000)
    x_queue.append(x)
    rejected_randomly = 0
    accepted_burnin = 0
    for i in range(burnin):
        x_new = propose_step(x, bounds, sigma)
        funval_new = objective(x_new, *args)
        log_alpha = -(funval_new - funval)*beta
        if log_alpha > 0 or np.log(np.random.rand()) <= log_alpha:
            x = x_new
            funval = funval_new
            x_queue.append(x)
            accepted_burnin += 1
        elif log_alpha <= 0:
            rejected_randomly += 1
        # end if
    # end for
    ar = float(accepted_burnin)/burnin

    pts = np.array(x_queue)
    plt.scatter(pts[:,0], pts[:,1], alpha=0.1, s=5)
    plt.xlim(bounds.lb[0], bounds.ub[0])
    plt.ylim(bounds.lb[1], bounds.ub[1])
    plt.show()

    accepted = 0

# end func


if __name__ == "__main__":
    # DEV TESTING
    def obj_fun(x, mu, cov):
        # The number returned from the function must be non-negative.
        # The exponential of the negative of this value is the probablity.
        dims = len(x)
        x2fac = np.sqrt(np.matmul(np.matmul((x - mu).T, cov.T), x - mu))
        return x2fac
    # end func

    mu = np.array([0, 1])
    cov = np.array([[5, -6.0], [-6.0, 20.0]])
    fixed_args = (mu, cov)
    bounds = Bounds(np.array([-3, -2]), np.array([3, 4]))

    optimize_minimize_mhmcmc_cluster(obj_fun, bounds, fixed_args, burnin=10000, maxiter=100000)
# end if
